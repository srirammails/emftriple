-- @atlcompiler atl2006
-- @nsURI ecore=http://www.eclipse.org/emf/2002/Ecore
-- @path owl=platform://com.emf4sw.owl/model/owl2.ecore

--- *******************************************************************************
--- * Copyright (c) 2009 L3i ( http://l3i.univ-larochelle.fr ).
--- * All rights reserved. This program and the accompanying materials
--- * are made available under the terms of the Eclipse Public License v1.0
--- * which accompanies this distribution, and is available at
--- * http://www.eclipse.org/legal/epl-v10.html
--- *
--- *******************************************************************************/

module owl2ecore;
create OUT:ecore from IN:owl;

--- =============================================================================
--- OWL2Ecore
--- version 1.8
---	OWL2 support
--- release date : 15/03/2010
--- author : Guillaume Hillairet (g.hillairet@gmail.com)
--- =============================================================================
	
uses OWLHelpers;
uses OWL2EcoreHelpers;

helper def: ID: Integer = 1;
	
rule Ontology2EPackage {
	from o : owl!Ontology
	using {
		ns: String = 
			if (o.getURI().endsWith('#'))
				then o.getURI().substring(1, o.getURI().size()-1) 
				else o.getURI() 
			endif;
		lname: String = ns.resolveLocalName();
	}
	to e : ecore!EPackage (
		name <- lname,
		nsURI <- ns,
		nsPrefix <- lname,
		eClassifiers <- Sequence {
			o.listClassExpressions(),
			thisModule.allDatatypes
		},
		eAnnotations <- Sequence{ann_rdf}
	),
	ann_rdf: ecore!EAnnotation ( source <- 'OWL', details <- Sequence{ann_uri, ann_prefix} ),
	ann_prefix: ecore!EStringToStringMapEntry ( key <- 'prefix', value <- lname ),
	ann_uri: ecore!EStringToStringMapEntry ( key <- 'uri', value <- o.URI )
}
	
abstract rule ClassExpression2OWLClass {
	from o: owl!ClassExpression
	using {
		objectProperties: Set(owl!ObjectProperty) = thisModule.objectProperties->select(p | p.listDomains()->includes(o));
		dataProperties: Set(owl!DataProperty) = thisModule.dataProperties->select(p | p.listDomains()->includes(o));
		superTypes: Sequence(owl!ClassExpression) = o.listSuperTypes();
	}
	to
		e:ecore!EClass (
			eSuperTypes <- superTypes,
			eStructuralFeatures <- Sequence {
				objectProperties->union( dataProperties )->collect(e | 
					let 
						range : owl!Entity = e.listRanges()->first() 
					in
					if (range.oclIsUndefined()) then
						thisModule.OWLProperty2EStructuralFeature(e, o, thisModule.Thing)
					else thisModule.OWLProperty2EStructuralFeature(e, o, range) endif)->flatten()
			},
			eAnnotations <- Sequence{ann_rdf}
		),
		ann_rdf: ecore!EAnnotation ( source <- 'OWLClass') --, details <- Sequence{} )
}

rule OWLClass2EClass extends ClassExpression2OWLClass {
	from o : owl!OWLClass (not o.getURI().oclIsUndefined())
	using {
		name : String = if (o.name.oclIsUndefined()) then o.getName() else o.name endif;
	}
	to	e : ecore!EClass (
		name <- o.getName()
	)
--	ann_rdf: ecore!EAnnotation ( details <- Sequence{ann_uri, ann_name} ),
--	ann_uri: ecore!EStringToStringMapEntry ( key <- 'uri', value <- '' ),
--	ann_name: ecore!EStringToStringMapEntry ( key <- 'name', value <- name )
}

abstract rule AnonymousClassExpression extends ClassExpression2OWLClass {
	from o:owl!ClassExpression ( not o.oclIsTypeOf(owl!OWLClass) )
	to
		e:ecore!EClass ()
}
	
rule ObjectUnionOf2EClass extends AnonymousClassExpression {
	from o:owl!ObjectUnionOf
	to
		e:ecore!EClass (
			name <- o.getName(),
			eSuperTypes <- superTypes->union(o.listEquivalentClasses()->reject(c | c = o)->asSet()),
			abstract <- true,
			interface <- true,
			eAnnotations <- Sequence{ann_rdf}
		),
		ann_rdf: ecore!EAnnotation ( source <- 'ObjectUnionOf') -- details <- Sequence{})-- --ann_unionOf} ),
--		ann_unionOf: ecore!EStringToStringMapEntry ( 
--			key <- 'unionOf',
--			value <- thisModule.commaSeparatedNames( o.unionOf ) 
--		)		
	do {
		thisModule.ID <- thisModule.ID + 1;
	}
}

rule ObjectIntersectionOf2EClass extends AnonymousClassExpression {
	from o:owl!ObjectIntersectionOf
	to
		e:ecore!EClass (
			name <- o.getName(),
			abstract <- true,
			eAnnotations <- Sequence{ann_rdf}
		),
		ann_rdf: ecore!EAnnotation ( source <- 'ObjectIntersectionOf') -- details <- Sequence{ann_interOf} ),
--		ann_interOf: ecore!EStringToStringMapEntry ( 
--			key <- 'intersectionOf', 
--			value <- thisModule.commaSeparatedNames( o.intersectionOf ) 
--		)
		
	do {
		thisModule.ID <- thisModule.ID + 1;
	}
}

--- ==========================================================================================================================
--- Cardinality Restriction

rule ObjectExactCardinality2EClass extends AnonymousClassExpression {
	from o:owl!ObjectExactCardinality
	using {
		range: owl!ClassExpression = 
			if (o.onClass.oclIsUndefined()) then  
				o.onProperty.get().listRanges()->first()
			else o.onClass endif; 
	}
	to
		e:ecore!EClass (
			name <- o.getName(),
			abstract <- true,
			eStructuralFeatures <- Sequence {
				thisModule.OWLProperty2EStructuralFeature(o.onProperty.get(), o, range)
			},
			eAnnotations <- Sequence{ann_rdf}
		),
		ann_rdf: ecore!EAnnotation ( source <- 'ObjectExactCardinality', details <- Sequence{ann_onProperty} ),
		ann_onProperty: ecore!EStringToStringMapEntry ( key <- 'onProperty', value <- o.onProperty.getName() )
		
	do {
		thisModule.ID <- thisModule.ID + 1;
	}
}

rule DataExactCardinality2EClass extends AnonymousClassExpression {
	from o:owl!DataExactCardinality
	using {
		range: owl!DataRange = 
			if (o.onDataRange.oclIsUndefined()) then  
				o.onProperty.get().listRanges()->first()
			else o.onDataRange endif; 
	}
	to
		e:ecore!EClass (
			name <- o.getName(),
			abstract <- true,
			eStructuralFeatures <- Sequence {
				thisModule.OWLProperty2EStructuralFeature(o.onProperty.get(), o, range)
			},
			eAnnotations <- Sequence{ann_rdf}
		),
		ann_rdf: ecore!EAnnotation ( source <- 'DataExactCardinality', details <- Sequence{ann_onProperty} ),
		ann_onProperty: ecore!EStringToStringMapEntry ( key <- 'onProperty', value <- o.onProperty.getName() )
		
	do {
		thisModule.ID <- thisModule.ID + 1;
	}
}

rule ObjectMaxCardinality2EClass extends AnonymousClassExpression {
	from o:owl!ObjectMaxCardinality
	using {
		range: owl!ClassExpression = 
			if (o.onClass.oclIsUndefined()) then  
				o.onProperty.get().listRanges()->first()
			else o.onClass endif; 
	}
	to
		e:ecore!EClass (
			name <- o.getName(),
			abstract <- true,
			eStructuralFeatures <- Sequence {
				thisModule.OWLProperty2EStructuralFeature(o.onProperty.get(), o, range)
			},
			eAnnotations <- Sequence{ann_rdf}
		),
		ann_rdf: ecore!EAnnotation ( source <- 'ObjectMaxCardinality', details <- Sequence{ann_onProperty} ),
		ann_onProperty: ecore!EStringToStringMapEntry ( key <- 'onProperty', value <- o.onProperty.getName() )
		
	do {
		thisModule.ID <- thisModule.ID + 1;
	}
}

rule DataMaxCardinality2EClass extends AnonymousClassExpression {
	from o:owl!DataMaxCardinality
	using {
		range: owl!DataRange = 
			if (o.onDataRange.oclIsUndefined()) then  
				o.onProperty.get().listRanges()->first()
			else o.onDataRange endif; 
	}
	to
		e:ecore!EClass (
			name <- o.getName(),
			abstract <- true,
			eStructuralFeatures <- Sequence {
				thisModule.OWLProperty2EStructuralFeature(o.onProperty.get(), o, range)
			},
			eAnnotations <- Sequence{ann_rdf}
		),
		ann_rdf: ecore!EAnnotation ( source <- 'DataMaxCardinality', details <- Sequence{ann_onProperty} ),
		ann_onProperty: ecore!EStringToStringMapEntry ( key <- 'onProperty', value <- o.onProperty.getName() )
		
	do {
		thisModule.ID <- thisModule.ID + 1;
	}
}

rule ObjectMinCardinality2EClass extends AnonymousClassExpression {
	from o:owl!ObjectMinCardinality
	using {
		range: owl!ClassExpression = 
			if (o.onClass.oclIsUndefined()) then  
				o.onProperty.get().listRanges()->first()
			else o.onClass endif; 
	}
	to
		e:ecore!EClass (
			name <- o.getName(),
			abstract <- true,
			eStructuralFeatures <- Sequence {
				thisModule.OWLProperty2EStructuralFeature(o.onProperty.get(), o, 
					if (range.oclIsUndefined()) then thisModule.Thing else range endif)
			},
			eAnnotations <- Sequence{ann_rdf}
		),
		ann_rdf: ecore!EAnnotation ( source <- 'ObjectMinCardinality', details <- Sequence{ann_onProperty} ),
		ann_onProperty: ecore!EStringToStringMapEntry ( key <- 'onProperty', value <- o.onProperty.getName() )
		
	do {
		thisModule.ID <- thisModule.ID + 1;
	}
}

rule DataMinCardinality2EClass extends AnonymousClassExpression {
	from o:owl!DataMinCardinality
	using {
		range: owl!DataRange = 
			if (o.onDataRange.oclIsUndefined()) then  
				o.onProperty.get().listRanges()->first()
			else o.onDataRange endif; 
	}
	to
		e:ecore!EClass (
			name <- o.getName(),
			abstract <- true,
			eStructuralFeatures <- Sequence {
				thisModule.OWLProperty2EStructuralFeature(o.onProperty.get(), o, range)
			},
			eAnnotations <- Sequence{ann_rdf}
		),
		ann_rdf: ecore!EAnnotation ( source <- 'DataMinCardinality', details <- Sequence{ann_onProperty} ),
		ann_onProperty: ecore!EStringToStringMapEntry ( key <- 'onProperty', value <- o.onProperty.getName() )
		
	do {
		thisModule.ID <- thisModule.ID + 1;
	}
}

--- ==========================================================================================================================
--- Value Restriction

rule ObjectAllValuesFrom2EClass extends AnonymousClassExpression {
	from o:owl!ObjectAllValuesFrom
	to
		e:ecore!EClass (
			name <- o.getName(),
			abstract <- true,
			eStructuralFeatures <- Sequence {
				thisModule.OWLProperty2EStructuralFeature(o.onProperty.get(), o, o.allValuesFrom)
			},
			eAnnotations <- Sequence{ann_rdf}
		),
		ann_rdf: ecore!EAnnotation ( source <- 'ObjectAllValuesFrom', details <- Sequence{ann_onProperty} ),
		ann_onProperty: ecore!EStringToStringMapEntry ( key <- 'onProperty', value <- o.onProperty.getName() )
		
	do {
		thisModule.ID <- thisModule.ID + 1;
	}
}

rule ObjectSomeValuesFrom2EClass extends AnonymousClassExpression {
	from o:owl!ObjectSomeValuesFrom
	to
		e:ecore!EClass (
			name <- o.getName(),
			abstract <- true,
			eStructuralFeatures <- Sequence {
				thisModule.OWLProperty2EStructuralFeature(o.onProperty.get(), o, o.someValuesFrom)
			},
			eAnnotations <- Sequence{ann_rdf}
		),
		ann_rdf: ecore!EAnnotation ( source <- 'ObjectSomeValuesFrom', details <- Sequence{ann_onProperty} ),
		ann_onProperty: ecore!EStringToStringMapEntry ( key <- 'onProperty', value <- o.onProperty.getName() )
		
	do {
		thisModule.ID <- thisModule.ID + 1;
	}
}

rule DataAllValuesFrom2EClass extends AnonymousClassExpression {
	from o: owl!DataAllValuesFrom
	using {
		range: owl!DataRange = if (o.allValuesFrom.oclIsUndefined()) then thisModule.XString else o.allValuesFrom endif;
	}
	to
		e: ecore!EClass (
			name <- o.getName(),
			abstract <- true,
			eStructuralFeatures <-
				if (range.oclIsUndefined()) then Sequence{} else
					Sequence {
						thisModule.OWLProperty2EStructuralFeature(o.onProperties->first().get(), o, range)
					}
				endif,
			eAnnotations <- Sequence{ann_rdf}
		),
		ann_rdf: ecore!EAnnotation ( source <- 'DataAllValuesFrom', details <- Sequence{ann_onProperty} ),
		ann_onProperty: ecore!EStringToStringMapEntry ( key <- 'onProperty', value <- o.onProperty.getName() )
	
	do {
		thisModule.ID <- thisModule.ID + 1;
	}
}

rule DataSomeValuesFrom2EClass extends AnonymousClassExpression {
	from o:owl!DataSomeValuesFrom
	using {
		range: owl!DataRange = if (o.someValuesFrom.oclIsUndefined()) then thisModule.XString else o.someValuesFrom endif;
	}
	to
		e:ecore!EClass (
			name <- o.getName(),
			abstract <- true,
			eStructuralFeatures <-
				if (range.oclIsUndefined()) then Sequence{} else
				Sequence {
					thisModule.OWLProperty2EStructuralFeature(o.onProperties->first().get(), o, o.someValuesFrom)
				} endif,
			eAnnotations <- Sequence{ann_rdf}
		),
		ann_rdf: ecore!EAnnotation ( source <- 'DataSomeValuesFrom', details <- Sequence{ann_onProperty} ),
		ann_onProperty: ecore!EStringToStringMapEntry ( key <- 'onProperty', value <- o.onProperty.getName() )
	do {
		thisModule.ID <- thisModule.ID + 1;
	}
}

--- ==========================================================================================================================
--- Properties

lazy abstract rule OWLProperty2EStructuralFeature {
	from
		o: owl!OWLProperty,
		domain: owl!ClassExpression,
		type: OclAny
	using {
--		minCard: Integer = o.getMinCard(domain); 
--		maxCard: Integer = o.getMaxCard(domain);
--		card: Integer = o.getCard(domain); 
--		lower: Integer = o.getLower(minCard, card);			
--		upper: Integer = o.getUpper(maxCard, card);			
	}
	to
		e: ecore!EStructuralFeature (
			name <- o.getName(),
			lowerBound <- 0,
			upperBound <- 0-1,
			eAnnotations <- Sequence{ann_rdf}
		),
		ann_rdf: ecore!EAnnotation ( details <- Sequence{ann_uri} ),
		ann_uri: ecore!EStringToStringMapEntry ( key <- 'uri', value <- o.getURI() )
}

lazy rule DataPropertyNull2EAttribute extends OWLProperty2EStructuralFeature {
	from
		o: owl!DataProperty,
		domain: owl!ClassExpression,
		type: owl!ClassExpression
	using {
		datatype: owl!DataType = thisModule.allDatatypes->any(d | d.getURI() = thisModule.XSD + 'string');
	}
	to
		e : ecore!EAttribute (
			eType <- datatype
		),
		ann_rdf: ecore!EAnnotation (source <- 'DataProperty')
}

lazy rule DataProperty2EAttribute extends OWLProperty2EStructuralFeature {
	from
		o: owl!DataProperty,
		domain: owl!ClassExpression,
		type: owl!DataRange
	using {
		datatype: owl!DataType = 
			if not type.oclIsKindOf(owl!ClassExpression) then
				thisModule.allDatatypes->any(d | d.getURI() = thisModule.XSD + 'string')	
			else thisModule.allDatatypes->any(d | d.getURI() = type.getURI()) endif;
	}
	to
		e : ecore!EAttribute (
			eType <- datatype
		),
		ann_rdf: ecore!EAnnotation (source <- 'DataProperty') 
}

lazy abstract rule ObjectProperty2EReference extends OWLProperty2EStructuralFeature {
	from
		o: owl!ObjectProperty,
		domain: owl!ClassExpression,
		type: owl!ClassExpression
	to
		e : ecore!EReference (),
		ann_rdf: ecore!EAnnotation (source <- 'ObjectProperty')
}

lazy rule ObjectPropertyWithInverse2EReference extends ObjectProperty2EReference {
	from
		o : owl!ObjectProperty,
		domain: owl!ClassExpression,
		type: owl!ClassExpression ( not o.listInverseProperties().isEmpty() )
	using {
		aType: owl!ClassExpression = if (type.oclIsKindOf(owl!EntityExpression)) then type.reference else type endif;
	}
	to
		e : ecore!EReference (
			eType <- aType,
			eOpposite <- o.listInverseProperties()->first()
		)
}

lazy rule ObjectPropertyWithoutInverse2EReference extends ObjectProperty2EReference {
	from
		o : owl!ObjectProperty,
		domain: owl!ClassExpression,
		type: owl!ClassExpression ( o.listInverseProperties().isEmpty() )
	using {
		aType: owl!ClassExpression = if (type.oclIsKindOf(owl!EntityExpression)) then type.reference else type endif;
	}
	to
		e : ecore!EReference (
			eType <- aType
		)
}

rule DataType2EDataType {
	from o : owl!Datatype ( thisModule.allDatatypes->includes( o ) )
	to e : ecore!EDataType (
		name <- 
			if (thisModule.xsd2ecore.get(o.getURI()).oclIsUndefined()) then
				thisModule.xsd2ecore.get('http://www.w3.org/2001/XMLSchema#string') 
			else 
				thisModule.xsd2ecore.get(o.getURI()) 
			endif,
		eAnnotations <- Sequence{ann_rdf}
	),
	ann_rdf: ecore!EAnnotation ( source <- 'DataType', details <- Sequence{ann_uri} ),
	ann_uri: ecore!EStringToStringMapEntry ( key <- 'uri', value <- o.getURI() )
}
