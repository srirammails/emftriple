-- @atlcompiler atl2006
-- @nsURI owl=http://www.emf4sw.org/2009/OWL
-- @nsURI ecore=http://www.eclipse.org/emf/2002/Ecore
-- @nsURI Properties=http://com.atl.commons/2010/Properties

-- *******************************************************************************
-- * Copyright (c) 2009 L3i ( http://l3i.univ-larochelle.fr ).
-- * All rights reserved. This program and the accompanying materials
-- * are made available under the terms of the Eclipse Public License v1.0
-- * which accompanies this distribution, and is available at
-- * http://www.eclipse.org/legal/epl-v10.html
-- *******************************************************************************/

module ecore2owl;
create OUT:owl from IN:ecore, IN2:Properties;

-- 	=============================================================================
-- 	Ecore2OWL
-- 	version 1.7
-- 	release date : 01/03/2010
-- 	author : Guillaume Hillairet (g.hillairet@gmail.com)
--  =============================================================================

uses Ecore2OWLHelpers;
uses PropertiesHelpers;

helper def: Property: Properties!PropertyMap = Properties!PropertyMap.allInstancesFrom('IN2')->first();
helper def: ECORE2OWL_NO_DOMAIN_NO_RANGE: String = 'ECORE2OWL_NO_DOMAIN_NO_RANGE';
helper def: ECORE2OWL_NO_CARDINALITIES: String = 'ECORE2OWL_NO_CARDINALITIES';
helper def: ECORE2OWL_PROPERTY_NAME_ONLY: String = 'ECORE2OWL_PROPERTY_NAME_ONLY';
helper def: ECORE2OWL_PROPERTY_NAME_DELIMITER: String = 'ECORE2OWL_PROPERTY_NAME_DELIMITER';

helper def: doCardinalities(): Boolean = 
	if (thisModule.Property.containsKey(thisModule.ECORE2OWL_NO_CARDINALITIES)) then
		let doIt: String = thisModule.Property.get(thisModule.ECORE2OWL_NO_CARDINALITIES) in
			doIt = 'false'
	else true endif;

helper def: doDomainAndRange(): Boolean = 
	if (thisModule.Property.containsKey(thisModule.ECORE2OWL_NO_DOMAIN_NO_RANGE)) then
		let doIt: String = thisModule.Property.get(thisModule.ECORE2OWL_NO_DOMAIN_NO_RANGE) in
			doIt = 'false'
	else true endif;

helper def: doPropertyNameOnly(): Boolean = 
	if (thisModule.Property.containsKey(thisModule.ECORE2OWL_PROPERTY_NAME_ONLY)) then
		let doIt: String = thisModule.Property.get(thisModule.ECORE2OWL_PROPERTY_NAME_ONLY) in
			doIt = 'true'
	else true endif;

helper def: getDelimiter: String = 
	if (thisModule.Property.containsKey(thisModule.ECORE2OWL_PROPERTY_NAME_DELIMITER)) then
		let delimiter: String = thisModule.Property.get(thisModule.ECORE2OWL_PROPERTY_NAME_DELIMITER) in
			delimiter
	else '_' endif;

helper def: getPropertyName(e: ecore!EStructuralFeature): String =
	if (thisModule.doPropertyNameOnly()) then 
		e.name 
	else e.eContainingClass.name + thisModule.getDelimiter + e.name endif;

rule EPackage2Ontology
{
	from e: ecore!EPackage
	using
	{
		imported: Set(ecore!EPackage) = e.getImportedPackages();
		classifiers: Set(ecore!EClassifier) = e.eClassifiers;
	}
	to 
		o : owl!Ontology (
			URI <- e.getURI(),
			imports <- imported->collect(i | thisModule.MakeImportedPackage(i)),
			annotations <- label_ann,
			axioms <- Sequence {
				label_property,
				classifiers->reject(e | e.oclIsTypeOf(ecore!EEnum))->collect(c |
						Sequence{c}->append(
							if (c.oclIsTypeOf(ecore!EClass)) then
								c.eSuperTypes->collect(s | 
									if (s.oclIsTypeOf(ecore!EClass)) then
										thisModule.SubClassOf(c,s)
									else Sequence{} endif)->flatten()
							else Sequence {} endif
						)->append(
							if (c.oclIsTypeOf(ecore!EClass)) then
								c.eStructuralFeatures
									->collect(feat |
									Sequence {
										Sequence{feat},
										if (thisModule.doDomainAndRange()) then 
											if (not feat.eType.oclIsTypeOf(ecore!EEnum)) then
												thisModule.PropertyDomain(feat, feat.eContainingClass)
											else Sequence{} endif
										else Sequence{} endif,
										if (thisModule.doDomainAndRange()) then
											if (not feat.eType.oclIsTypeOf(ecore!EEnum)) then
												thisModule.PropertyRange(feat, feat.eType)
											else Sequence{} endif
										else Sequence{} endif,
										if (thisModule.doCardinalities()) then
											if (feat.isCardinality()) then 
												thisModule.PropertyCardinality(feat)
											else Sequence{} endif
										else Sequence{} endif,
										if (feat.oclIsTypeOf(ecore!EReference)) then
											thisModule.ObjectSomeValuesFrom(feat, feat.eType)
										else Sequence{} endif
									}->flatten()
						) 	else Sequence {} endif ) ),
						e.allDatatypes()->collect(d | thisModule.MakeImportedDataType(d, e)) },
			namespaces <- Sequence { thisModule.Namespace( e ), rdf, rdfs, owl, xsd }
		),
--		label: owl!AnnotationAxiom(property <- label_property_exp, annotations <- label_ann),
		label_property_exp: owl!PrefixEntityExpression(namespace <- rdfs, reference <- label_entity),
		label_ann: owl!Annotation(property <- label_property_exp, value <- label_ann_val),
		label_ann_val: owl!Literal (value <- e.name),
		label_property: owl!Declaration(entity <- label_entity),
		label_entity: owl!AnnotationProperty(name <- 'label', namespace <- rdfs),
		
		rdf: owl!Namespace (name <- 'rdf', URI <- thisModule.RDF),
		rdfs: owl!Namespace (name <- 'rdfs', URI <- thisModule.RDFS),
		owl: owl!Namespace (name <- 'owl', URI <- thisModule.OWL),
		xsd: owl!Namespace (name <- 'xsd', URI <- thisModule.XSD)	
}

unique lazy rule Namespace {
	from e: ecore!EPackage
	to
		o: owl!Namespace (
			name <- e.name,
			URI <- e.getNamespace()
		)
}

unique lazy rule MakeImportedPackage
{
	from e: ecore!EPackage
	to
		o : owl!Ontology (
			URI <- e.getURI()
		)
}

--	=============================================================================================
-- 	Entity
--	=============================================================================================

unique lazy abstract rule ENamedElement2Entity {
	from e: ecore!ENamedElement
	to
		o: owl!Entity (
			name <- e.name,
			namespace <- thisModule.Namespace( e.getOntology() )
		)
}

unique lazy rule EClass2Entity extends ENamedElement2Entity {
	from e: ecore!EClass (not e.isAbstract())
	to
		o: owl!OWLClass ()
}

unique lazy rule AbstractEClass2Entity extends ENamedElement2Entity {
	from e: ecore!EClass (e.isAbstract())
	to
		o: owl!OWLClass ()
}

unique lazy rule EAttribute2Entity extends ENamedElement2Entity {
	from e: ecore!EAttribute
	using {
		name: String = thisModule.getPropertyName(e);
	}
	to
		o: owl!DataProperty (
			name <- name
		)
}

unique lazy rule EReference2Entity extends ENamedElement2Entity {
	from e: ecore!EReference
	using {
		name: String = thisModule.getPropertyName(e);
	}
	to
		o: owl!ObjectProperty (
			name <- name	
		)
}

unique lazy rule EDataType2Entity extends ENamedElement2Entity {
	from e: ecore!EDataType
	to
		o: owl!Datatype (
			name <- 
				if (thisModule.datatypes_names.get(e.name).oclIsUndefined()) then
					'Literal' 
				else thisModule.datatypes_names.get(e.name) endif,
			namespace <-
				if (thisModule.datatypes.get(e.name).oclIsUndefined()) then
					thisModule.resolveTemp(e.ePackage, 'rdfs')
				else thisModule.resolveTemp(e.ePackage, 'xsd') endif
		)
}

---	=============================================================================================
--- 	Declaration
---	=============================================================================================

rule EClass2Declaration {
	from e: ecore!EClass
	to 
		o: owl!Declaration (
			entity <- thisModule.ENamedElement2Entity(e)
		)
}

abstract rule EStructuralFeature2Declaration {
	from e: ecore!EStructuralFeature
	to
		o: owl!Declaration (
			entity <- thisModule.ENamedElement2Entity(e)
		)
}

rule EAttribute2Declaration extends EStructuralFeature2Declaration {
	from e: ecore!EAttribute
	to
		o: owl!Declaration (
			entity <- thisModule.ENamedElement2Entity(e)
		)
}

rule EReference2Declaration extends EStructuralFeature2Declaration {
	from e: ecore!EReference
	to
		o: owl!Declaration (
			entity <- thisModule.ENamedElement2Entity(e)
		)
}

rule EDataType {
	from e: ecore!EDataType (e.oclIsTypeOf(ecore!EDataType))
	to
		o: owl!Declaration (
			entity <- thisModule.ENamedElement2Entity(e)
		)
}

lazy rule EEnum2DataOneOf {
	from e: ecore!EEnum		
	to
		o: owl!DataOneOf (
			literals <- e.eLiterals->collect(e | thisModule.EnumLiteral2Literal(e))
		)
}

lazy rule EnumLiteral2Literal {
	from e: ecore!EEnumLiteral
	to
		o: owl!Literal (
			value <- e.name
--			datatypeExpression <- exp
		)
--		exp: owl!PrefixEntityExpression (
--			entity <- thisModule.Literal(e.eContainer().ePackage)
--			namespace <- thisModule.resolveTemp(e.eContainer().ePackage, 'rdfs')
--		)
}

unique lazy rule Literal {
	from e: ecore!EPackage
	to
		o: owl!Datatype (
			name <- 'Literal',
			namespace <- thisModule.resolveTemp(e, 'rdfs')
		),
		d: owl!Declaration (
			entity <- o
		)
}

unique lazy rule MakeImportedClass
{
	from e: ecore!EClass, p: ecore!EPackage
	to  
		d : owl!Declaration (
			entity <- o
		),
		o: owl!OWLClass (
			name <- e.name,
			namespace <- thisModule.Namespace( e.getOntology() )
		)
}

unique lazy rule MakeImportedDataType {
	from e: ecore!EDataType, p: ecore!EPackage
	to
		d: owl!Declaration (
			entity <- thisModule.MakeDatatype(e, p)
		)
}

unique lazy rule MakeDatatype {
	from e: ecore!EDataType, p: ecore!EPackage
	to
		o: owl!Datatype (
			name <- 
				if (thisModule.datatypes_names.get(e.name).oclIsUndefined()) then
					'Literal'
				else thisModule.datatypes_names.get(e.name) endif,
			namespace <-
				if (thisModule.datatypes.get(e.name).oclIsUndefined()) then
					thisModule.resolveTemp(p, 'rdfs')
				else thisModule.resolveTemp(p, 'xsd') endif		
		)
}

lazy rule CreatePrefixEntityExpression {
	from e: ecore!ENamedElement
	to
		o: owl!PrefixEntityExpression ( 
			reference <- thisModule.ENamedElement2Entity(e),
			namespace <- thisModule.Namespace( e.getOntology() )
		)
}

lazy rule CreateDatatypeExpression {
	from e: ecore!ENamedElement, p: ecore!EPackage
	to
		o: owl!PrefixEntityExpression (
			reference <- thisModule.MakeDatatype(e, p)			
		)
}

---	=============================================================================================
--- 	Class Axiom
---	=============================================================================================
	
lazy rule SubClassOf {
	from e: ecore!EClass, sup: ecore!EClass
	to
		o: owl!SubClassOf (
			subClass <- thisModule.CreatePrefixEntityExpression(e),
			superClass <- thisModule.CreatePrefixEntityExpression(sup)
--				thisModule.CreatePrefixEntityExpression (
--					if (not thisModule.allClasses->includes(sup)) then 
--						thisModule.MakeImportedClass(sup, e.ePackage) 
--					else sup endif)
		)
}

---	=============================================================================================
--- 	Property Axiom
---	=============================================================================================
	
lazy abstract rule PropertyDomain {
	from
		e: ecore!EStructuralFeature, dom: ecore!EClass
	to
		o: owl!Axiom ()
}

lazy abstract rule PropertyRange {
	from
		e: ecore!EStructuralFeature, ran: ecore!EClassifier
	to
		o: owl!Axiom ()
}

---	=============================================================================================
--- 	DataProperty Axiom
---	=============================================================================================
	
lazy rule DataPropertyDomain extends PropertyDomain {
	from
		e: ecore!EAttribute, dom: ecore!EClass
	to
		o: owl!DataPropertyDomain (
			property <- thisModule.CreatePrefixEntityExpression(e),
			domain <- thisModule.CreatePrefixEntityExpression(dom)
		)
}

lazy rule DataPropertyRange extends PropertyRange { 
	from
		e: ecore!EAttribute, ran: ecore!EDataType
	to
		o: owl!DataPropertyRange (
			property <- thisModule.CreatePrefixEntityExpression(e),
			range <- 
				if (not ran.oclIsTypeOf(ecore!EEnum)) then 
					if (thisModule.allClassifiers->includes(ran)) then
						thisModule.CreatePrefixEntityExpression(ran)
					else thisModule.CreateDatatypeExpression(ran, e.eContainingClass.ePackage) endif
				else thisModule.EEnum2DataOneOf(ran) endif
		)
}

---	=============================================================================================
--- 	ObjectProperty Axiom
---	=============================================================================================

lazy rule ObjectPropertyDomain extends PropertyDomain {
	from e: ecore!EReference, dom: ecore!EClass
	to
		o: owl!ObjectPropertyDomain (
			property <- thisModule.CreatePrefixEntityExpression(e),
			domain <- thisModule.CreatePrefixEntityExpression(dom)
		)
}

lazy rule ObjectPropertyRange extends PropertyRange {
	from e: ecore!EReference, ran: ecore!EClass
	to
		o: owl!ObjectPropertyRange (
			property <- thisModule.CreatePrefixEntityExpression(e),
			range <- thisModule.CreatePrefixEntityExpression(ran)
		)
}

lazy rule InverseObjectProperties {
	from e: ecore!EReference, inv: ecore!EReference
	to
		o: owl!InverseObjectProperties (
			property <- thisModule.CreatePrefixEntityExpression(e),
			inverseProperty <- thisModule.CreatePrefixEntityExpression(inv)
		)
}

----	=============================================================================================
---- 	Restriction Axiom
----	=============================================================================================
	
lazy abstract rule PropertyCardinality {
	from property: ecore!EStructuralFeature
	to 
		o: owl!Axiom (
			superClass <- rest
		),
		rest: owl!ClassExpression ()
}

----	=============================================================================================
---- 	ObjectPropertyRestriction Axiom
----	=============================================================================================

lazy abstract rule ObjectPropertyCardinality extends PropertyCardinality 
{
	from property: ecore!EReference
	to 
		o: owl!Axiom (
			superClass <- rest
		),
		rest: owl!ClassExpression ()
}

lazy rule ObjectExactCardinality extends ObjectPropertyCardinality {
	from property: ecore!EReference  (
		property.upperBound = property.lowerBound
	)
	to
		o : owl!SubClassOf (
			subClass <- thisModule.CreatePrefixEntityExpression(property.eContainingClass)
		),
		rest: owl!ObjectExactCardinality (
			cardinality <- property.upperBound,
			onProperty <- thisModule.CreatePrefixEntityExpression(property),
			onClass <- thisModule.CreatePrefixEntityExpression(property.eContainingClass)
		)
}

lazy rule ObjectMaxCardinality extends ObjectPropertyCardinality {
	from property: ecore!EReference  (
		property.upperBound > 0 and property.lowerBound = 0
	)
	to
		o : owl!SubClassOf (
			subClass <- thisModule.CreatePrefixEntityExpression(property.eContainingClass),
			superClass <- rest
		),
		rest : owl!ObjectMaxCardinality (
			cardinality <- property.upperBound,
			onProperty <- thisModule.CreatePrefixEntityExpression(property),
			onClass <- thisModule.CreatePrefixEntityExpression(property.eContainingClass)
		)
}


lazy rule ObjectMinCardinality extends ObjectPropertyCardinality {
	from property: ecore!EReference  (
		property.upperBound < 0 and property.lowerBound > 0
	)
	to
		o : owl!SubClassOf (
			subClass <- thisModule.CreatePrefixEntityExpression(property.eContainingClass),
			superClass <- rest
		),
		rest: owl!ObjectMinCardinality (
			cardinality <- property.lowerBound,
			onProperty <- thisModule.CreatePrefixEntityExpression(property),
			onClass <- thisModule.CreatePrefixEntityExpression(property.eContainingClass)
		)
}

rule ObjectMinMaxCardinality extends ObjectPropertyCardinality {
	from property: ecore!EReference  (
		(property.upperBound <> property.lowerBound) and 
		(property.upperBound > 0) and 
		(property.lowerBound > 0)
	)
	to
		o : owl!SubClassOf (
			subClass <- thisModule.CreatePrefixEntityExpression(property.eContainingClass),
			superClass <- rest
		),
		rest : owl!ObjectMaxCardinality (
			cardinality <- property.upperBound,
			onProperty <- thisModule.CreatePrefixEntityExpression(property),
			onClass <- thisModule.CreatePrefixEntityExpression(property.eContainingClass)
		),
		o2 : owl!SubClassOf (
			subClass <- thisModule.CreatePrefixEntityExpression(property.eContainingClass),
			superClass <- rest2
		),	
		rest2 : owl!ObjectMinCardinality (
			cardinality <- property.lowerBound,
			onProperty <- thisModule.CreatePrefixEntityExpression(property),
			onClass <- thisModule.CreatePrefixEntityExpression(property.eContainingClass)
		)
}

lazy rule ObjectSomeValuesFrom {
	from e: ecore!EReference, c: ecore!EClass
	to
		o : owl!SubClassOf (
			subClass <- thisModule.CreatePrefixEntityExpression(c),
			superClass <- rest
		),		
		rest : owl!ObjectSomeValuesFrom (
			onProperty <- thisModule.CreatePrefixEntityExpression(e),
			someValuesFrom <- thisModule.CreatePrefixEntityExpression(e.eType)
		)
}

----	=============================================================================================
---- 	DataPropertyRestriction Axiom
----	=============================================================================================
	
lazy abstract rule DataPropertyCardinality extends PropertyCardinality 
{
	from property: ecore!EAttribute
	to	o: owl!Axiom ()
}

lazy rule DataExactCardinality extends DataPropertyCardinality {
	from property: ecore!EAttribute (
		property.upperBound = property.lowerBound
	)
	to
		o : owl!SubClassOf (
			superClass <- rest,
			subClass <- thisModule.CreatePrefixEntityExpression(property.eContainingClass)
		),
		rest: owl!DataExactCardinality (
			cardinality <- property.upperBound,
			onProperty <- thisModule.CreatePrefixEntityExpression(property)
		)
}

lazy rule DataMinCardinality extends DataPropertyCardinality {
	from property: ecore!EAttribute (
		not (property.upperBound > 0) and (property.lowerBound > 0)
	)
	to
		o : owl!SubClassOf (
			superClass <- rest,
			subClass <- thisModule.CreatePrefixEntityExpression(property.eContainingClass)
		),
		rest : owl!DataMinCardinality (
			cardinality <- property.lowerBound,
			onProperty <- thisModule.CreatePrefixEntityExpression(property)
		)
}

lazy rule DataMaxCardinality extends DataPropertyCardinality {
	from property: ecore!EAttribute (
		(property.upperBound > 0) and (property.lowerBound = 0)
	)
	to
		o : owl!SubClassOf (
			superClass <- rest,
			subClass <- thisModule.CreatePrefixEntityExpression(property.eContainingClass)
		),
		rest : owl!DataMaxCardinality (
			cardinality <- property.upperBound,
			onProperty <- thisModule.CreatePrefixEntityExpression(property)
		)
}

rule DataMinMaxCardinality extends DataPropertyCardinality {
	from property: ecore!EAttribute (
		property.upperBound <> property.lowerBound and property.upperBound > 0 and property.lowerBound > 0
	)
	to
		o : owl!SubClassOf (
			superClass <- rest,
			subClass <- thisModule.CreatePrefixEntityExpression(property.eContainingClass)
		),
		rest : owl!DataMaxCardinality (
			cardinality <- property.upperBound,
			onProperty <- thisModule.CreatePrefixEntityExpression(property)
		),
		o2 : owl!SubClassOf (
			subClass <- thisModule.CreatePrefixEntityExpression(property.eContainingClass),
			superClass <- rest2
		),
		rest2 : owl!DataMinCardinality (
			cardinality <- property.lowerBound,
			onProperty <- thisModule.CreatePrefixEntityExpression(property)
		)
}
