-- @atlcompiler atl2006

-- @path Properties=/com.atl.common/model/Properties.ecore
-- @path RDF=/com.emf4sw.rdf/model/rdf.ecore
-- @nsURI Model=http://www.eclipse.org/emf/2002/Ecore

module Model2Rdf;
create OUT:RDF from IN:Model, IN2:Properties;

uses RDFHelpers;
uses PropertiesHelpers;

--- NAMESPACES
helper def: NS_EMF4SW: String = 'http://eclipselabs.org/emf4sw#';
helper def: etype: String = thisModule.NS_EMF4SW + 'etype';

--- PROPERTY HELPERS
helper def: PROPERTY: Properties!PropertyMap = Properties!PropertyMap.allInstancesFrom('IN2').first();
helper def: BASE(): String = thisModule.PROPERTY.get('OPTION_BASE_NAMESPACE');
helper def: OPTION_DIRECT_TYPE_ONLY(): Boolean = 
	if thisModule.PROPERTY.containsKey('OPTION_DIRECT_TYPE_ONLY') then
		let doIt: String = thisModule.get('OPTION_DIRECT_TYPE_ONLY') in
			doIt = 'true'
	else false endif;
helper def: OPTION_NO_ECORE_TYPE(): Boolean = 
	if thisModule.PROPERTY.containsKey('OPTION_NO_ECORE_TYPE') then
		let doIt: String = thisModule.get('OPTION_NO_ECORE_TYPE') in
			doIt = 'true'
	else false endif;	

--- Return the types of an object
-- return all hierarchy types if OPTION_DIRECT_TYPE_ONLY set to false, direct type otherwise
helper context OclAny def: eTypes(): Set(String) =
	Set{self.eClass().getURI()}
	->union(
		if thisModule.OPTION_DIRECT_TYPE_ONLY() then Set{} else 
			Set{self.eClass().eAllSuperTypes->collect(e | e.getURI())}
		endif)->flatten();

--- Return the unique object URI
helper context OclAny def: getID(): String = 
	let id: Model!EAttribute = 
		self.eClass().eAllAttributes->any(e | e.iD)
	in if (not id.oclIsUndefined()) then
		thisModule.BASE() + self.eGet(id).toString()
	else
		let id2: Model!EAttribute =
			self.eClass().eAllAttributes->any(e | not e.getEAnnotation('Id').oclIsUndefined())
		in if (not id2.oclIsUndefined()) then
			let ns: String = id2.getEAnnotation('Id').details.get('base')
			in
				if (ns.oclIsUndefined()) then
					thisModule.BASE() + self.eGet(id2).toString()
				else ns + self.eGet(id2) endif
			else
				thisModule.BASE() + self.getEcoreId()
		endif
	endif;
	
rule EObject2Node {
	from e: Model!EObject
	using 
	{
		features: Sequence(OclAny) = e.getFeatures();
		g: String = e.eClass().getGraph();
		annotations: Set(Model!EAnnotation) = e.eClass().getEAnnotations();
		types: Set(Model!EAnnotation) = annotations->select(a | a.source.contains('OWLClass'));
	}
	to	
		r: RDF!Resource (
			URI <- e.getID()
		,	graph <- if (g = thisModule.Graph) then thisModule.DocumentGraph(g) else thisModule.NamedGraph(g) endif
		,	subjectOf <- Sequence {
				thisModule.MakeTripleWithURI(e, thisModule.etype, e.eClass().getURI(), e.eClass().getGraph()),
				if (types.isEmpty()) then
					e.eTypes()->collect(t | 
					thisModule.MakeTripleWithURI(e, thisModule.RDF + 'type', t, e.eClass().getGraph()))
				else
					types->collect(t | 
						thisModule.MakeTripleWithURI(e, 
							thisModule.RDF + 'type', 
							t.details.get('uri'),
							e.eClass().getGraph()))
				endif,
				features->collect(f |
					let 
						val: Sequence(OclAny) = thisModule.set( e.eGet(f) ) 
					in
					let
						ann: Set(Model!EAnnotation)= f.getEAnnotations()
					in
					Sequence {
						val->collect(v |
							Sequence {
								if (f.oclIsKindOf(Model!EReference))
								then
									if (v.oclIsKindOf(Model!EDataType)) -- ???
									then
										thisModule.MakeTripleWithURI(e, f.getURI(), v.getRdfId(), e.eClass().getGraph())
									else
										thisModule.MakeTriple(e, f.getURI(), v, e.eClass().getGraph()) 
									endif
								else 
									thisModule.MakeTripleWithLiteral(e, f.getURI(), v, f.getType(), e.eClass().getGraph())
								endif
							})
			}->flatten()
		)}
	)
}

unique lazy rule BlankNode {
	from id: String
	to
		r: RDF!BlankNode (
			nodeID <- id
--		,	graph <- if (g = thisModule.Graph) then thisModule.DocumentGraph(g) else thisModule.NamedGraph(g) endif 
		)
}
