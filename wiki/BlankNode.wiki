#summary Installation and Setup.
#sidebar StoreTableOfContents

= Introduction =

[http://www.w3.org/TR/rdf-mt/#unlabel Blank nodes] are supported in emftriple, but under certain constraints. This page presents the solution of blank node handling in emftriple, and how your model should be configured in order to support this type of RDF nodes.

= Details =

Blank nodes in RDF indicates the existence of a thing without saying anything about the name of this thing. Thus a blank node cannot be uniquely identified like the other kind of RDF nodes (URI Resource). The example below shows the use of blank nodes. This example is written in the Turtle syntax, which makes reading blank nodes simpler than in RDF/XML.

Here we have a URI Resource acting as the subject. This URI denotes a thing of type Person. This Person has a name, and is link to two other things by a property books. Those two things are instance of the class Book, but are also blank nodes (identified by [] in turtle syntax).

While it is not a so good practice to really on blank nodes, this can be find in many RDF data available on the Web.

{{{
@prefix model: <http://www.eclipselabs.org/emf/junit#> .
@prefix data: <http://www.eclipselabs.org/emf/junit/person/> .

data:f68b5b7c-1c67-455b-860c-6fd000348434
      a       model:Person ;
      model:books [
	      	a       model:Book ;
	      	model:authors data:f68b5b7c-1c67-455b-860c-6fd000348434> ;
	      	modeL:title "Book of Things"^^<http://www.w3.org/2001/XMLSchema#string> 
      ] ;
      model:books [              
	      a       model:Book ;
	      model:authors data:f68b5b7c-1c67-455b-860c-6fd000348434 ;
              model:title "Valley Of Thing"^^<http://www.w3.org/2001/XMLSchema#string> 
      ] ;
      model:name "John Doe"^^<http://www.w3.org/2001/XMLSchema#string> .
}}}

The problem is that emftriple creates EObject proxies when it creates EObject during the load of RDF data. EObject proxies are assigned a URI, that is used to reload the content of the object, thanks to a SPARQL query, when it is ask to. But this technique cannot be used with blank nodes since they are treated as non-distinguished variables by SPARQL (see [http://www.w3.org/TR/rdf-sparql-query/#QSynBlankNodes this]).

To enable handling of blank nodes in emftriple, you first need to mark which classes of your model will create blank nodes. This is done by adding annotations. The easiest way to add annotations on an EMF model is to use a textual syntax like [http://wiki.eclipse.org/Emfatic emfatic].

In emfatic, we can write the following classes. The class Book has an annotation @BlankNode. This annotation will tell emftriple that instances of this class are blank nodes. Thus emftriple will create specific queries to load these objects. 

{{{
class Person {
  attr String name;
  val Book[*] books; // important !!! blank nodes can only be used in containment references.
}

@BlankNode(foo=bar)
class Book {
   attr String title;
   ref Person[*] authors;
}
}}}

If you don't want all the instances of a class to be blank nodes, you can use the annotation @BlankNode on a reference. Thus only instances contained in the reference will be loaded and saved as blank nodes.

{{{
class Person {
  attr String name;
  @BlankNode
  val Book[*] books; // important !!! blank nodes can only be used in containment references.
}
}}}